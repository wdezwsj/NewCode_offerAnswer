牛客剑指offer目录

1.二维数组中的查找  (右上角或左下角为起点，注意边界即可)

2.替换空格  (遍历一遍字符串的所有字符，碰到空格就换成'%20')

3.从尾到头打印链表  (遍历一遍链表，往ArrayList头插)

4.重建二叉树  (根据前序遍历找到root节点，再根据中序遍历分隔为左右子树，重复上述步骤即可)

5.用两个栈实现队列  (入队列用一个栈存储元素，出队列时借用辅助栈实现栈内元素倒置，恢复FIFO特性)

6.旋转数组的最小数字  (没啥意思，跳过)

7.斐波那契数列  (迭代完成，本质是状态转移，要注意起始点)

8.跳台阶  (本质就是菲波那切数列，最好用迭代做)

9.变态跳台阶  (动态规划问题)

10.矩形覆盖  (思路同第八题)

11.二进制中1的个数  (与1相与判断最低位是否为1，然后右移一位继续判断，int类型参数右移32位即可完全判断二进制数中1的个数)

12.数值的整数次方  (调用Math.pow函数解决即可)

13.调整数组顺序使奇数位于偶数前面  (冒泡排序的思想，偶数的下一位是奇数，则二者互换)

14.链表中倒数第k个结点  (两个指针位于起点，第一个先走k步，从第k+1步开始二者一起前进 ; 等价于单指针法的用时)

15.反转链表  (三个关键变量：pre，current，next)

16.合并两个排序的链表  (构造一个辅助链表头，然后用归并排序的思路链成一条排序链表)

17.树的子结构  (先通过前序遍历寻找用于比较的起始节点，再从该起始节点起比较两树的左子树和右子树是否相等，只有当root2提前或与root1同时遍历到null时才返回true)

18.二叉树的镜像  (用前序遍历的方式，将root节点的左右孩子互换)

19.顺时针打印矩阵  (分解为多次的打印二维数组最外围的行为，每次打印只用确定左上角和右下角即可，特别情况需考虑打印单行或单列)

20.包含min函数的栈  (保证min函数O(1)的时间复杂度，所有的操作放在push当中完成。push时，一个栈存放正常入栈的值，另一个栈重复存放当前最小的值)

21.栈的压入、弹出序列  (借助一个辅助栈来模拟入栈和出栈操作，操作结束后若辅助栈为空，则表示给定的压入和弹出序列可以匹配)

22.从上往下打印二叉树  (借助队列来实现，从队列中每取一个节点，就相应的将该节点的左右孩子节点入队列，直到队列取到空为止)

23.二叉搜索树的后序遍历序列  (了解二叉搜索树和后序遍历的性质，对于给定的序列，我们可知最后一个值对应着root节点，由此我们要判断该root节点是否可将该给定序列分为两部分，然后继续对分好的两部分继续进行判断)

24.二叉树中和为某一值的路径  (采用前序遍历的方式判断路径和是否满足target，注意路径的定义以及元素的回退操作)

25.复杂链表的复制  (分三步，第一步原链表中插入复制节点；第二步给复制节点添加随机指针；第三步将原链表和复制链表分隔开)

26.二叉搜索树与双向链表  (单元步骤：将左子树转换为链表并返回左子树的链表头，遍历到左链表的尾节点和root节点相连；再将右子树转换为链表并返回右子树的链表头，然后和root节点相连)

27.字符串的排列  (对于每一个位置的字符，都需要和后面的字符交换来确定，确定完一个位置，就继续确定下一个位置，注意回退时的交换操作)

28.数组中出现次数超过一半的数字  (遍历记录当前数字及该数字出现的次数，数字相等计数加一，数字不等计数减一，计数为0则记录当前数字。最后需要再遍历一遍数组判断该数字出现次数是否超过一半)

29.最小的K个数  (topK问题，构造大小为k的堆，然后不停的和堆顶元素进行比较并替换，遍历完数组后堆中的元素即为所求topK个元素)

30.连续子数组的最大和  (遍历数组计算累加值，并每次与max值进行比较替换。当累加值小于0时，则重新计算累加值)

31.整数中1出现的次数 （弄清楚十进制每一位上，每隔多久出现多少个1。先计算整数部分，对于每一位的计算，要注意余数部分1的数量的计算）

32.把数组排成最小的数  (自定义排序规则，对于任两个整数A和B，当AB < BA，则A排在B的前面)

33.丑数  (一个辅助数组存放已求得的丑数，分别用三个指针代表2,3,5乘积因子所处的位置，每次计算最小值放入数组中并将对应乘积因子的指针右移)

34.第一个只出现一次的字符位置  (借助LinkedHashMap实现)

35.数组中的逆序对  (归并的思路，每次计算出一个模块当中的逆序对，模块当中的从高位往低位计算)

36.两个链表的第一个公共结点  (分别遍历两个链表求得二者长度之差，然后长的链表先走差值步数，再二者再同时前进，一边前进一边比较节点是否相等)

37.数字在排序数组中出现的次数  (用二分查找分别找k-0,5和k+0.5时返回的index值，二者相减即是出现的次数)

38.二叉树的深度  (后序遍历，树的深度的左右子树的深度的最大值+1)

39.平衡二叉树  (同样是通过后序遍历获取左右子树的深度，判断左右子树的深度差值)

40.数组中只出现一次的数字  (异或运算的原理)

41.和为S的连续正数序列  (可变滑动窗口原理，窗口内数值和小了就右指针右移，大了就左指针右移，等于就记录，特别注意边界条件！)

42.和为S的两个数字  (左右加逼法)

43.左旋转字符串  (通过求余得到实际左移量，然后借助String的subString方法对原字符串进行拆分再合并)

44.翻转单词顺序列  (字符串分隔，反向重构)

45.扑克牌顺子  (先排序，然后计算赖子的数量，再计算空缺值，当赖子数量大于等于空缺值时就可以组成顺子)

46.圆圈中最后剩下的数  (约瑟夫环，关键点在于理解n-1人当中的第k人是n人当中的第(m+k)%n人)

47.求1+2+3+...+n  (递归代替循环，短路与来代替if判断)

48.不用加减乘除做加法  (两数相与再左移一位等到两数相加的进位结果，两数异或得到不考虑进位的两数相加的结果，重复上面两步操作直到进位结果为0)

49.把字符串转换成整数  (首先考虑符号位，再依次遍历字符判断是否在0-9之间，最后拼接)

50.数组中重复的数字  (遍历数组，把遍历得到的数据与它本该放置的位置的数据做交换，直至当前遍历的index和值相等，再遍历下一个数)

51.构建乘积数组  (正向遍历一次，再反向遍历一次)

52.正则表达式匹配  (先判断pattern下一位是否为'*'，再判断str和pattern当前位是否相等，其中'*'就算匹配上了也分用和不用两种情况，结束条件是str和pattern都遍历到尾部)

53.表示数值的字符串  (就算按给定的规则对遍历的字符进行判断，弄清楚规则即可)

54.字符流中第一个不重复的字符  (LRU算法)

55.链表中环的入口结点  (双指针二倍速法，公式推导见题解)

56.删除链表中重复的结点  (构造虚拟头节点，遍历链表的过程中使用两个指针pre和cur，判断cur和下一个结点是否相等，若相等则继续向后判断，直到不等时把pre节点链过去)

57.二叉树中序遍历的下一个结点  (若有右子树，则返回右子树的最左叶子节点；若该结点为父节点的左孩子，则返回父节点；否则继续向上找父节点)

58.对称的二叉树  (前序遍历即 中-》左-》右的结果应该和 中-》右-》左的结果相同)

59.按之字形顺序打印二叉树  (本质和60题一样，只不过需要标志位来控制遍历方向)

60.把二叉树打印成多行  (逐层传递上一层的节点队列)

61.序列化二叉树  (通过前序遍历把二叉树转换成字符串，再通过前序遍历把字符串恢复成二叉树，关键在于空节点也要进行序列化)

62.二叉搜索树的第k个结点  (基于中序遍历，依靠全局变量计数，只有当计数为k时才返回当前节点，否则一律返回null)

63.数据流中的中位数  (构造一个大顶堆一个小顶堆，小顶堆中的数都比大顶堆的要大，取中位数只需取两个堆的堆顶计算即可)

64.滑动窗口的最大值  (借助一个辅助队列记录当前窗口内的最大值索引，每次前进都要考虑最大值是否过期，并将新进入窗口的索引放入辅助队列中，比它小的都应被移除)

65.矩阵中的路径  (回溯法，对于每个格子的下一步都有上下左右四种走法，四种走法有一种为true就行，记得flag的标记与回退时的清除标记)

66.机器人的运动范围  (回溯法，同样每个格子有四种走法，返回四种走法的能走到的点的和，加上自身即是答案，flag标记不用回退，代表已访问过)